<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spew13 — Gambling Room</title>
<style>
  /* Matrix background */
  html,body { height:100%; margin:0; font-family:Arial, sans-serif; background:#000; color:#e6ffe6; overflow:hidden; }
  #matrixCanvas { position:fixed; top:0; left:0; width:100%; height:100%; z-index:-2; display:block; }

  /* Spew13 neon header + layout */
  header {
    background:#111;
    border-bottom:4px solid limegreen;
    color:limegreen;
    padding:18px 22px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    box-shadow:0 8px 40px rgba(0,255,136,0.03);
    position:relative;
    z-index:10;
  }
  header h1 { margin:0; font-size:1.4rem; letter-spacing:1px; }
  .top-controls { display:flex; gap:10px; align-items:center; }

  /* Main panel styling */
  main { max-width:1100px; margin:26px auto; padding:0 20px 80px 20px; position:relative; z-index:5; }
  .balance {
    background:rgba(0,0,0,0.6);
    border:2px solid rgba(0,255,136,0.12);
    padding:10px 14px;
    border-radius:10px;
    font-weight:700;
    color:limegreen;
    box-shadow:0 6px 24px rgba(0,255,136,0.04);
  }
  .save-btn, .close-btn {
    background:#0b0b0b;
    color:white;
    border:2px solid rgba(0,255,136,0.16);
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer;
  }
  .save-btn:hover, .close-btn:hover { transform:translateY(-2px); }

  .muted { color:#9fbf9f; }

  .game-grid { display:grid; grid-template-columns:1fr 1fr; gap:18px; margin-top:22px; }
  .panel {
    background: linear-gradient(180deg,#0f0f0f,#0a0a0a);
    border:2px solid rgba(0,255,136,0.06);
    padding:16px;
    border-radius:12px;
    box-shadow:0 12px 40px rgba(0,0,0,0.6);
  }
  .panel h2 { margin:0 0 8px 0; color:#bfffbe; }

  .controls-row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:10px; }
  input[type=number] { padding:8px; border-radius:8px; background:#111; color:#fff; border:2px solid rgba(255,255,255,0.04); width:110px; }

  .btn { background:limegreen; color:#0b0b0b; padding:9px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:700; }
  .btn.small { padding:8px 10px; font-size:0.95rem; }
  .btn.ghost { background:transparent; border:2px solid rgba(255,255,255,0.06); color:#fff; }

  .table { background:linear-gradient(90deg,#08240a,#07110a); padding:12px; border-radius:8px; min-height:86px; color:#fff; margin-top:12px; }
  .card { display:inline-block; width:48px; height:72px; line-height:72px; text-align:center; border-radius:6px; background:#fff; color:#000; font-weight:800; margin-right:8px; box-shadow:0 8px 18px rgba(0,0,0,0.6); }
  .card.hidden { background:#222; color:#fff; }

  .poker-card { display:inline-block; width:56px; height:84px; line-height:84px; text-align:center; border-radius:8px; background:#fff; color:#000; font-weight:800; margin-right:8px; box-shadow:0 8px 18px rgba(0,0,0,0.6); cursor:pointer; }
  .poker-card.held { outline:3px solid rgba(0,255,136,0.25); background:#dfffd9; }
  .status { margin-left:10px; color:#cfeecf; font-weight:700; }

  footer { color:#9fbf9f; text-align:center; margin-top:28px; font-size:0.95rem; opacity:0.9; }

  /* responsive */
  @media (max-width:900px) { .game-grid{grid-template-columns:1fr} .card{width:40px;height:60px;line-height:60px} .poker-card{width:48px;height:72px;line-height:72px} }

</style>
</head>
<body>
  <canvas id="matrixCanvas"></canvas>

  <header>
    <h1>Gambling Room</h1>
   <div class="top-controls">
  <div id="balanceDisplay" class="balance">Spews: 0</div>
  <button id="saveBtn" class="save-btn">Save</button>
<button id="loadBtn" class="load-btn">Load</button>

<script>
  const saveBtn = document.getElementById('saveBtn');
  const loadBtn = document.getElementById('loadBtn');

  // Example: some data to save
  function getSiteState() {
    // Collect any state you want to save
    // Example: text content, input values, or even innerHTML
    return {
      bodyContent: document.body.innerHTML
    };
  }

  function setSiteState(state) {
    // Restore the saved state
    document.body.innerHTML = state.bodyContent;
  }

  // Save site state to localStorage
  saveBtn.addEventListener('click', () => {
    const state = getSiteState();
    localStorage.setItem('spew13State', JSON.stringify(state));
    alert('Site saved!');
  });

  // Load site state from localStorage
  loadBtn.addEventListener('click', () => {
    const savedState = JSON.parse(localStorage.getItem('spew13State'));
    if (savedState) {
      setSiteState(savedState);
      alert('Site loaded!');
    } else {
      alert('No saved data found.');
    }
  });
</script>

 <button id="closeBtn" class="close-btn">Close</button>

<!-- Loading overlay -->
<div id="loadingOverlay">
  <div class="spinner"></div>
  <p>Resetting...</p>
</div>

<style>
  /* Overlay styles */
  #loadingOverlay {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.8);
    color: #fff;
    font-size: 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  }

  /* Spinner styles */
  .spinner {
    width: 60px;
    height: 60px;
    border: 6px solid #fff;
    border-top: 6px solid #0f0; /* lime-green accent */
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>

<script>
  const closeBtn = document.getElementById('closeBtn');
  const loadingOverlay = document.getElementById('loadingOverlay');

  closeBtn.addEventListener('click', () => {
  // Show overlay
  loadingOverlay.style.display = 'flex';

  // Send message to parent to close/remove iframe
  try { 
    parent.postMessage({ type: 'closeGambling' }, '*'); 
  } catch(e) {}

  // Hide overlay after short delay so it never freezes
  setTimeout(() => {
    loadingOverlay.style.display = 'none';
  }, 1200);
});

</script>


</div>
  </header>

  <main>
    <div class="muted">Welcome fellow people...</div>

    <div class="game-grid">
      <!-- Blackjack -->
      <section class="panel">
        <h2>Blackjack</h2>
        <div class="muted">Bet amount</div>
        <div class="controls-row">
          <input id="bjBet" type="number" min="1" value="10" />
          <button id="bjDeal" class="btn small">Deal</button>
          <button id="bjHit" class="btn small" disabled>Hit</button>
          <button id="bjStand" class="btn small" disabled>Stand</button>
          <div class="status" id="bjStatus">Ready</div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Player</div>
          <div id="bjPlayer" class="table"></div>

          <div class="muted" style="margin-top:10px">Dealer</div>
          <div id="bjDealer" class="table"></div>
        </div>
      </section>

      <!-- Poker -->
      <section class="panel">
        <h2>Poker</h2>
        <div class="muted">Bet amount</div>
        <div class="controls-row">
          <input id="pokerBet" type="number" min="1" value="10" />
          <button id="pokerDeal" class="btn small">Deal</button>
          <button id="pokerDraw" class="btn small" disabled>Draw</button>
          <div class="status" id="pokerStatus">Ready</div>
        </div>

        <div style="margin-top:12px">
          <div class="muted">Your hand (click cards to hold)</div>
          <div id="pokerPlayer" style="margin-top:10px"></div>

          <div class="muted" style="margin-top:12px">Dealer's hand</div>
          <div id="pokerDealer" style="margin-top:10px"></div>
        </div>
      </section>
    </div>

    <footer>© Green Iguana & AR Studios</footer>
  </main>

<script>
/* ---------------- Matrix background (same feel as Spew13) ---------------- */
const canvas = document.getElementById('matrixCanvas');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; columns = Math.floor(canvas.width / fontSize); drops = new Array(columns).fill(0); }
const letters = "01";
const fontSize = 18;
let columns = Math.floor(window.innerWidth / fontSize);
let drops = new Array(columns).fill(0);
resize();
window.addEventListener('resize', resize);
function draw(){
  ctx.fillStyle = "rgba(0,0,0,0.08)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#32CD32";
  ctx.font = fontSize + "px monospace";
  for(let i=0;i<drops.length;i++){
    const text = letters.charAt(Math.floor(Math.random()*letters.length));
    ctx.fillText(text, i*fontSize, drops[i]*fontSize);
    drops[i]++;
    if(drops[i]*fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
  }
}
setInterval(draw, 80);

/* ---------------- Spew Coins (triple Base64 storage) ---------------- */
const STORAGE_KEY = 'spewCoins_v1';
let spewCoins = 0;

function encodeTriple(obj){
  let s = JSON.stringify(obj);
  for(let i=0;i<3;i++) s = btoa(s);
  return s;
}
function decodeTriple(s){
  try{ for(let i=0;i<3;i++) s = atob(s); return JSON.parse(s); }
  catch(e){ console.warn('decode fail', e); return { amount: 0 }; }
}

function saveSpew(){ try { localStorage.setItem(STORAGE_KEY, encodeTriple({ amount: spewCoins })); flashSave(); } catch(e) { console.warn(e); } updateBalance(); }
function loadSpew(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(!raw){ spewCoins = 100; saveSpew(); return; }
  const obj = decodeTriple(raw); spewCoins = obj.amount || 0; updateBalance();
}
function updateBalance(){ const el = document.getElementById('balanceDisplay'); if(el) el.textContent = `Spew Coins: ${spewCoins}`; }
function changeCoins(delta){ spewCoins = Math.max(0, Math.floor(spewCoins + delta)); updateBalance(); }

function flashSave(){
  const btn = document.getElementById('saveBtn');
  btn.style.transform = 'translateY(-2px)';
  setTimeout(()=> btn.style.transform = '', 300);
}
document.getElementById('saveBtn').addEventListener('click', saveSpew);

/* auto-save */
setInterval(() => saveSpew(), 20000);

/* send message to parent on close */
document.getElementById('closeBtn').addEventListener('click', ()=> {
  try { parent.postMessage({ type: 'closeGambling' }, '*'); } catch(e) {}
});

/* ---------------- Helper: deck functions ---------------- */
const SUITS = ['♠','♥','♦','♣'];
const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
function newDeck(){ const d=[]; for(const s of SUITS) for(const r of RANKS) d.push({r,s}); for(let i=d.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [d[i], d[j]] = [d[j], d[i]]; } return d; }
function valueBJ(r){ if(r==='A') return 11; if(['J','Q','K'].includes(r)) return 10; return parseInt(r,10); }
function scoreBJ(cards){ let total=0, aces=0; for(const c of cards){ total += valueBJ(c.r); if(c.r==='A') aces++; } while(total>21 && aces>0){ total -= 10; aces--; } return total; }

/* ---------------- Blackjack (fixed payouts) ---------------- */
(function(){
  const playerEl = document.getElementById('bjPlayer');
  const dealerEl = document.getElementById('bjDealer');
  const statusEl = document.getElementById('bjStatus');
  const betInput = document.getElementById('bjBet');
  const dealBtn = document.getElementById('bjDeal');
  const hitBtn = document.getElementById('bjHit');
  const standBtn = document.getElementById('bjStand');

  let deck = [], player = [], dealer = [], currentBet = 0, roundActive = false;

  function render(container, cards, hideFirst=false){
    container.innerHTML = '';
    cards.forEach((c,i)=> {
      const d = document.createElement('div');
      d.className = 'card' + (hideFirst && i===0 ? ' hidden' : '');
      if(hideFirst && i===0) d.textContent = '🂠';
      else d.textContent = c.r + c.s;
      if(!d.classList.contains('hidden')) {
        if(c.s === '♥' || c.s === '♦') d.style.color = '#b00';
        else d.style.color = '#000';
      }
      container.appendChild(d);
    });
  }

  function endRound(message, payoutMultiplier=0){
    // RoundActive ends, payoutMultiplier indicates how much to add relative to bet:
    // payoutMultiplier === 0: player already lost (bet already removed)
    // payoutMultiplier === 1: return bet (push) -> add back bet
    // payoutMultiplier === 2: win (player gets 2x bet back: return bet + winnings = bet*2)
    // payoutMultiplier === 2.5: blackjack (return bet + 1.5*bet)
    roundActive = false;
    hitBtn.disabled = true; standBtn.disabled = true; dealBtn.disabled = false;
    if(payoutMultiplier > 0 && currentBet > 0){
      const pay = Math.floor(currentBet * payoutMultiplier);
      changeCoins(pay);
      statusEl.textContent = `${message} — you received ${pay} Spew Coins.`;
    } else {
      statusEl.textContent = message;
    }
  }

  function dealerPlayResolve(){
    render(dealerEl, dealer, false);
    let ds = scoreBJ(dealer);
    while(ds < 17){
      dealer.push(deck.pop());
      ds = scoreBJ(dealer);
    }
    const ps = scoreBJ(player);
    if(ps > 21){
      endRound('You busted — dealer wins', 0);
    } else if(ds > 21 || ps > ds){
      // player wins: payoutMultiplier = 2 -> add 2*bet (i.e. return bet + equal winnings)
      endRound('You win!', 2);
    } else if(ps === ds){
      // push: return bet only
      endRound('Push — tie', 1);
    } else {
      endRound('Dealer wins', 0);
    }
  }

  dealBtn.addEventListener('click', ()=>{
    if(roundActive) return;
    const bet = Math.max(1, Math.floor(Number(betInput.value) || 0));
    if(bet > spewCoins){ statusEl.textContent = 'Not enough Spew Coins.'; return; }
    currentBet = bet;
    // deduct bet upfront
    changeCoins(-currentBet);

    deck = newDeck();
    player = [deck.pop(), deck.pop()];
    dealer = [deck.pop(), deck.pop()];
    roundActive = true;
    dealBtn.disabled = true;
    hitBtn.disabled = false;
    standBtn.disabled = false;
    render(playerEl, player, false);
    render(dealerEl, dealer, true);
    const ps = scoreBJ(player);
    if(ps === 21){
      // Blackjack: payout multiplier 2.5 (return bet + 1.5*bet)
      render(dealerEl, dealer, false);
      endRound('Blackjack! You win big.', 2.5);
    } else {
      statusEl.textContent = 'Your move';
    }
  });

  hitBtn.addEventListener('click', ()=>{
    if(!roundActive) return;
    player.push(deck.pop());
    render(playerEl, player, false);
    const ps = scoreBJ(player);
    if(ps > 21){
      render(dealerEl, dealer, false);
      endRound('Bust — you lose', 0);
    } else statusEl.textContent = 'Your move';
  });

  standBtn.addEventListener('click', ()=>{
    if(!roundActive) return;
    hitBtn.disabled = true; standBtn.disabled = true;
    dealerPlayResolve();
  });

  // initialize
  render(playerEl, []); render(dealerEl, []);
  statusEl.textContent = 'Ready';
})();

/* ---------------- Poker (5-card draw, unchanged logic) ---------------- */
(function(){
  const playerDiv = document.getElementById('pokerPlayer');
  const dealerDiv = document.getElementById('pokerDealer');
  const dealBtn = document.getElementById('pokerDeal');
  const drawBtn = document.getElementById('pokerDraw');
  const status = document.getElementById('pokerStatus');
  const betInput = document.getElementById('pokerBet');

  const ORDER = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];

  function makeDeck(){
    const d = []; for(const s of SUITS) for(const r of RANKS) d.push({r,s});
    for(let i=d.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]]; }
    return d;
  }
  function label(c){ return c.r + c.s; }

  function evaluate(cards){
    // returns [rank, tieArray] similar to earlier
    const counts = {}; const suits = {};
    const vals = cards.map(c => ORDER.indexOf(c.r)).sort((a,b)=>a-b);
    cards.forEach(c=>{ counts[c.r]=(counts[c.r]||0)+1; suits[c.s]=(suits[c.s]||0)+1; });
    const isFlush = Object.values(suits).some(v=>v===5);
    let straight = true;
    for(let i=1;i<vals.length;i++) if(vals[i] !== vals[i-1]+1) { straight = false; break; }
    // A-low straight
    const aceLow = [0,1,2,3,12];
    if(vals.join(',') === aceLow.join(',')) straight = true;
    const groups = Object.values(counts).sort((a,b)=>b-a);
    const entries = Object.entries(counts).map(([r,c])=>({r,c,v:ORDER.indexOf(r)}));
    entries.sort((a,b)=> (b.c - a.c) || (b.v - a.v) );
    const tie = entries.map(e=>e.v);
    if(straight && isFlush) return [8,tie];
    if(groups[0]===4) return [7,tie];
    if(groups[0]===3 && groups[1]===2) return [6,tie];
    if(isFlush) return [5,tie];
    if(straight) return [4,tie];
    if(groups[0]===3) return [3,tie];
    if(groups[0]===2 && groups[1]===2) return [2,tie];
    if(groups[0]===2) return [1,tie];
    return [0,tie];
  }

  function compare(a,b){
    if(a[0] !== b[0]) return a[0] - b[0];
    const ta = a[1], tb = b[1];
    for(let i=0;i<Math.max(ta.length,tb.length);i++){
      const av = ta[i] || -1, bv = tb[i] || -1;
      if(av !== bv) return av - bv;
    }
    return 0;
  }

  let deck=[], ph=[], dh=[], holds=[false,false,false,false,false], round=false, usedRedraw=false, currentBet=0;

  function renderHands(hideDealer=true){
    playerDiv.innerHTML = '';
    ph.forEach((c,i)=> {
      const e = document.createElement('div');
      e.className = 'poker-card' + (holds[i] ? ' held' : '');
      e.textContent = label(c);
      e.addEventListener('click', ()=> {
        if(!round || usedRedraw) return;
        holds[i] = !holds[i]; renderHands(hideDealer);
      });
      playerDiv.appendChild(e);
    });
    dealerDiv.innerHTML = '';
    dh.forEach(c => {
      const e = document.createElement('div');
      e.className = 'poker-card';
      if(hideDealer){ e.textContent = '🂠'; e.style.background = '#333'; e.style.color = '#fff'; }
      else e.textContent = label(c);
      dealerDiv.appendChild(e);
    });
  }

  dealBtn.addEventListener('click', ()=> {
    if(round) return;
    const bet = Math.max(1, Math.floor(Number(betInput.value) || 0));
    if(bet > spewCoins){ status.textContent = 'Not enough Spew Coins.'; return; }
    currentBet = bet; changeCoins(-currentBet);
    deck = makeDeck(); ph = [deck.pop(),deck.pop(),deck.pop(),deck.pop(),deck.pop()];
    dh = [deck.pop(),deck.pop(),deck.pop(),deck.pop(),deck.pop()];
    holds = [false,false,false,false,false]; round = true; usedRedraw = false;
    drawBtn.disabled = false; dealBtn.disabled = true;
    status.textContent = 'Hold cards by clicking, then Draw';
    renderHands(true);
  });

  drawBtn.addEventListener('click', ()=> {
    if(!round || usedRedraw) return;
    for(let i=0;i<5;i++) if(!holds[i]) ph[i] = deck.pop();
    usedRedraw = true;
    renderHands(false);
    const pEval = evaluate(ph);
    const dEval = evaluate(dh);
    const cmp = compare(pEval, dEval);
    if(cmp > 0){
      // win -> pay 2x bet back (return bet+win)
      changeCoins(currentBet * 2);
      status.textContent = 'You win — ' + handName(pEval[0]);
    } else if(cmp === 0){
      changeCoins(currentBet); status.textContent = 'Push — tie';
    } else {
      status.textContent = 'Dealer wins — ' + handName(dEval[0]);
    }
    round = false; drawBtn.disabled = true; dealBtn.disabled = false;
  });

  function handName(s){
    switch(s){
      case 8: return 'Straight Flush';
      case 7: return 'Four of a Kind';
      case 6: return 'Full House';
      case 5: return 'Flush';
      case 4: return 'Straight';
      case 3: return 'Three of a Kind';
      case 2: return 'Two Pair';
      case 1: return 'One Pair';
      default: return 'High Card';
    }
  }

  // initial
  playerDiv.innerHTML = ''; dealerDiv.innerHTML = ''; drawBtn.disabled = true;
})();

/* ---------------- Init ---------------- */
loadSpew(); updateBalance();

</script>
</body>
</html>
